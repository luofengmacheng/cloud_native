## 如何实现一个简单的API认证系统(key和secret)

### 1 接口调用认证

云厂商在提供云上服务时，也提供api，让用户可以调用api实现自己的功能。由于是提供api进行调用，那就涉及到认证：让接口能够识别调用方的身份，并对调用方可以操作的对象和可以执行的操作进行访问控制。

通常，当用户需要调用云厂商的接口时，通常需要走以下几个步骤：

* 查看接口文档，生成key和secret
* 根据签名算法生成签名
* 确认接口的域名和接口的参数
* 执行接口调用

为什么调用接口时需要key和secret呢？其实就是确认调用方的身份，云厂商会管理用户信息，并将用户ID(或者是公司ID)加密为key，然后根据key生成secret并提供给用户。云厂商会从该key中解密出用户ID，于是就知道用户的身份。既然有了key就可以确认用户的身份，为什么还需要secret，其实就是安全保证，key是直接追加在请求中的，后面的签名算法中就使用到了secret，用于保证数据没有被篡改。

既然可以根据key提取出用户信息，那说明生成key的算法是可逆加密算法。而可逆加密算法又分为对称加密算法(AES、DES)和非对称加密算法(RSA)。

现在有了key和secret，在调用接口之前，通常还需要看下签名算法，签名算法的常见流程是：

* 对所有参数(包含key)按照字段名进行排序(可以按照升序或者降许排列)
* 对所有参数拼接，然后在后面附加上secret
* 使用散列算法对上面生成的字符串计算散列值，就得到签名，或者叫指纹
* 调用请求时除了必要的参数外，还需要带上key和签名

签名算法的基本流程都是这样，可能有变化的就是secret的用法以及散列算法：

* 有的将secret拼接到请求串中，然后使用SHA1算法生成签名(ucloud)
* 有的将secret作为密钥，使用HMAC-SHA256算法生成签名(qingcloud)

当云厂商收到该请求后，会执行以下验证流程：

* 根据key可以得到用户信息以及对应的secret
* 用上述同样的计算方式计算相应的签名
* 如果计算得到的签名和接收到的签名一致，就执行对应的业务逻辑，然后返回给用户

这里的关键就是secret和签名算法的作用：

* 签名算法其实就是指纹算法，用于保证数据没有被篡改，客户端计算签名并附加到请求串中，服务端用相同的算法计算签名，并与接收到的签名对比，从而判断数据没有被篡改
* 签名算法的计算流程是公开的(毕竟开发者也要用的)，如果黑客截获到请求串后，修改了部分参数然后使用相同的签名算法生成新的签名，然后替换掉原来的请求串中的签名，那是不是就可以冒充用户了呢？这里就体现出secret的作用，secret是不公开的，只是作为签名算法中的唯一变量。只要不知道secret，就不可能去修改请求串，一旦修改请求串，计算得到的签名也肯定通不过校验。

### 2 API认证系统实现

通过上述的说明，云厂商实现API认证系统分成几个部分：

* 管理用户信息，并管理生成的用户的key和secret
* 实现用户ID->key和secret的逻辑
* 实现请求串的验证逻辑

由于用户ID->key使用的是可逆加密算法，我们可以使用AES，而secret只是根key有关联关系，我们在用用户ID生成key后，可以随机生成一段文本作为secret，然后保存key和secret的对应关系，当然，如果可以用算法将key和secret关联起来更好。而请求串的验证逻辑基本就是签名算法的逻辑。
