## 【kubernetes】集群网络（二）：Flannel的VxLan、Host-GW模式

### 1 Pod的IP地址的分配

当节点上只安装了docker，则会用veth pair+docker0实现单个节点上容器之间的通信，并且这些容器都在同一个IP段，如果不修改，则默认为172.17.0.0/16，此时，docker0的ip就是网段的网关地址：172.17.0.1/16。那么，多个节点上的容器都在同一个网段，跨节点通信肯定会出现问题。

因此，在k8s集群中，对于网络而言，需要有以下准则：

* 集群中的每个Pod都有独立的IP地址，且不能出现冲突
* 集群中的Pod之间可以直接通过Pod IP进行通信，且不需要做地址转换

总的来说就是，集群中的Pod都会有自己的IP地址，且能够通过这个IP地址进行通信，就好像所有Pod都在同一个网络。

因此，第一个问题就是，如何给每个Pod分配一个不冲突的IP地址。

k8s的策略是：

* 整个集群在一个大的网段中，通常是一个16位的网段，kube-controller-manager的参数--cluster-cidr就是该网段
* 每个节点从集群的网段中取一个小的网段作为这个节点上所有Pod所在的网段，通常是一个24位的网段，node.spec.podCIDR可以看到该节点的Pod网段
* 每个Pod则从节点得到的网段中获取一个IP地址

这样就保证了所有Pod的IP都在一个大的网段中，并且不会冲突。

但是，如何让Pod之间可以通过Pod IP进行通信呢？这些IP毕竟是虚拟的，需要有一种机制能够实现Pod IP的相互通信。

### 2 CNI

CNI是容器网络接口的缩写，是K8S安装Pod网络的接口。

当kubelet创建Pod时，需要调用CNI接口为Pod安装网络：

* 分配Pod的IP
* 设置Pod的网络命名空间
* 配置Pod的路由

### 3 Flannel

Flannel是最简单也比较容易理解的一个网络插件。它的主要思想是将宿主机的网络作为隧道，将Pod之间通信的网络数据包封装为可以直接在宿主机上传输的数据包。由于Pod之间传输的数据包经过了底层网络的再封装和再解封装，可以知道，这种方式存在一定的性能损耗，不过，这种损耗在大部分场景下都是可以接受的，除非对性能要求非常高。

#### 3.1 Flannel的安装

Flannel的yaml可以从官网直接下载安装，需要注意的有两个地方：

* 使用的flannel镜像如果无法下载，可以将镜像仓库修改为quay.mirrors.ustc.edu.cn
* 如果有需要可以调整Pod网段，默认的网段是10.244.0.0/16

#### 3.2 VxLan

VxLan是一项用于在三层网络传输二层网络数据包的技术，只要底层的三层网络可达，就可以在三层网络之上建立二层网络，从而构建逻辑上的大二层网络。

![Flannel VxLan](https://github.com/luofengmacheng/cloud_native/blob/master/kubernetes/pics/flannel_vxlan.jpg)

上图就是两个node上的Pod之间通信的流程。

* node0的网段是10.244.0.0/24，node1的网段是10.244.1.0/24
* cni0是个网桥，网桥的IP地址是网段的网关，Pod中的容器通过veth pair接入到cni0，而机器上可以看到以veth开头的网卡
* 当node0上的container1发送数据给node1上的container1时，发送端是知道目的端的IP地址的，由于目的IP不在当前网段，因此，会发送给cni0网桥
* cni0网桥收到数据后，根据路由表将数据转发给flannel.1
* flannel.1是一个vxlan的设备，VNI是1，本地地址是172.16.16.202，本地设备是eth0，目的端口是8472，也就是说，当flannel.1收到数据包后，就会将数据包封装到UDP数据包中，然后发送到对端的8472端口，问题是，flannel.1怎么知道目的IP在哪个宿主机上呢？不然，发出去的数据包如何根据宿主机网络路由到目的IP所在的宿主机呢？按照k8s的机制，是可以通过查询etcd根据目的IP的网段知道宿主机网络中的目的IP。
* 由于目的端的网络子系统会监听8472，当node1收到数据后，flannel.1就会收到数据，然后将数据解封装后，根据路由交给cni0
* cni0收到数据后，根据目的IP的mac地址转发给对应的容器

#### 3.3 Host-GW

host-gw是直接走宿主机的网络，将对方的宿主机当做路由器进行转发。

![Flannel Host-GW](https://github.com/luofengmacheng/cloud_native/blob/master/kubernetes/pics/flannel_host_gw.jpg)

* Pod1向Pod3发送数据时，同样的，会通过veth pair将数据发送给cni0
* cni0根据路由表将数据发送给Pod3所在的宿主机
* Pod3所在的宿主机收到数据后，根据路由表将数据发送给cni0
* cni0再根据目的IP转发给Pod3

这里指导数据包流向的就是宿主机上面的路由，对于我们这里的场景，宿主机上面的路由可能是：

```
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         192.168.80.2    0.0.0.0         UG    0      0        0 ens33
10.244.0.0      192.168.80.241  255.255.255.0   UG    0      0        0 ens33
10.244.1.0      192.168.80.242  255.255.255.0   UG    0      0        0 ens33
10.244.2.0      0.0.0.0         255.255.255.0   U     0      0        0 cni0
```

第二条路由就是当前集群中的另一个节点，该节点的宿主机IP是192.168.80.241，网段是10.2440.0./24，因此，当cni0收到发往10.244.0.0/24网段的Pod的数据包时，会根据该路由将数据包发送给192.168.80.241，发出去的接口是ens33。

第四条路由就是当前节点的网段，当本机收到发往当前节点的Pod的数据包时，会根据该条路由将数据包发送给cni0，然后cni0就可以将数据包发送给目的Pod。

这种方式是直接将目的Pod的宿主机作为网关，不会对数据包进行额外的封装解封装，因此，这种模式的性能比较高，它的缺点是，宿主机必须在同一个网段中，所以，在云环境中可能需要其他的组件支持。

### 4 总结

Flannel作为k8s中广泛使用的网络插件，它的实现相对容易理解，它还提供了不同的模式，常用的是VxLan和Host-GW，由于Host-GW要求宿主机在同一个网段，使用受限，因此，最常用的还是VxLan。
