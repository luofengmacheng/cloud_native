## 面向kubernetes编程

### 1 云原生12要素

* 基准代码：一份基准代码，多分拷贝
* 依赖：显示声明依赖关系
* 配置：在环境中存储配置，从环境变量中获取配置
* 后端服务：把后端服务当作附加资源
* 构建、发布、运行：严格分离构建和运行
* 进程：以一个或多个无状态进程运行应用
* 端口绑定：通过端口绑定提供服务
* 并发：通过进程模型进行扩展
* 易处理：快速启动和优雅终止可最大化健壮性(应用需要处理终止信号)
* 环境等价：尽可能的保持开发、预发布、线上环境相同
* 日志：把日志当作事件流，将日志输出到stdout
* 管理进程：后台管理任务当作一次性进程运行

### 2 如何面向kubernetes编程

#### 2.1 组件容器化及容器化的优化

* 最小化父镜像
* 分离构建阶段镜像和生产环境镜像(构建时可以使用官方的镜像，会包含很多调试工具；而构建完成后的)
* 保持一致的构建步骤(Dockerfile前面的部分可以不变，可以利用缓存)

#### 2.2 组合容器为Pod

对于解释型语言(php、python)，需要安装其它的组件(例如，对于php，需要安装nginx、php-fpm等；对于python，需要安装uwsgi)，可以将这些其它的组件放到Pod的单独的容器(Sidecar)中，而业务逻辑则放到另一个容器中

对于编译型语言(golang、rust、c、c++)，一个Pod通常只包含一个容器

#### 2.3 如何管理应用配置

使用ConfigMap进行配置的管理，但是`ConfigMap不支持灰度`。

ConfigMap和Secret通常用于传递配置，它们都可以将配置导入为环境变量或者文件。当ConfigMap导入为文件并以卷的形式挂载到容器时，配置文件的内容是可以动态更新的，kubelet会每隔一段时间访问apiserver获取最新内容，并更新容器中的文件，因此，当集群节点较多时，会对apiserver的负载有影响。

于是，配置文件动态更新需要注意的是：

* 如果需要使用配置文件动态更新的特性，不要从环境变量读取配置，而以卷的方式挂载到文件
* 应用需要自行观测文件变量并刷新配置，或者使用第三方的库，或者使用configmap-reload作为sidecar监测configmap的变化并调用webhook

#### 2.4 通过Downward API获取容器/Pod/节点信息

#### 2.5 自定义服务的启动顺序

Pod中可以定义多个容器，而多个容器的启动是没有先后顺序的，可以在Pod中定义initContainers让某些容器可以先启动，某些容器后启动。

如果是服务的先后顺序，可以用initContainers搭配readiness探针实现：系统中有A、B两个服务，B服务启动时要依赖A服务，此时，可以在B服务的Pod定义的initContainers中对A服务进行解析(只有服务正常启动了，才能够解析服务，可以使用nslookup进行解析)，如果解析生成，就说明A服务已经正常启动，然后就可以启动B服务了。

#### 2.6 java应用内存限制

对于jvm，如果没有设置堆大小，就会按照宿主机环境的内存大小缺省设置自己的最大堆大小，当在容器中运行java应用时，会配置应用的可用内存大小，但是实际上java应用还是用的缺省大小，从而会导致java应用OOM。

* 对于java8及以上，可以在启动时加个额外的参数，UserCGroupMemory
* 如果版本较低，可以通过环境变量，在启动应用时设置堆大小

#### 2.7 利用lxcfs提升容器资源可见性

Linux利用CGroup实现对容器的资源限制，但在容器内部依然缺省挂载了宿主机上的procfs的/proc目录，其中包含meminfo、cpuinfo、stat、uptime等资源使用信息。一些监控工具如free/top或遗留应用还依赖于上述文件内容或者资源配置和使用情况。当它们在容器中运行时，就会把宿主机的资源状态读取出来，引起错误和不便。

#### 2.8 应用负载和交付

* 针对特定的应用选择对应的工作负载(workload)
* 外部的应用如何访问集群中的应用(如果是7层，可以使用ingress，如果是4层，可以用LB)
* 通过Operator(Custom Resource Definition和Custom Controller)进行应用的交付